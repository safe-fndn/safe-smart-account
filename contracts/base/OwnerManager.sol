// SPDX-License-Identifier: LGPL-3.0-only
pragma solidity >=0.7.0 <0.9.0;

import {EIP7702} from "../common/EIP7702.sol";
import {SelfAuthorized} from "../common/SelfAuthorized.sol";
import {IOwnerManager} from "../interfaces/IOwnerManager.sol";

/**
 * @title Owner Manager
 * @notice Manages Safe owners and a threshold to authorize transactions.
 * @dev Uses a linked list to store the owners because the code generated by the solidity compiler
 *      is more efficient than using a dynamic array.
 * @author Stefan George - @Georgi87
 * @author Richard Meissner - @rmeissner
 */
abstract contract OwnerManager is EIP7702, SelfAuthorized, IOwnerManager {
    /**
     * @dev The sentinel owner value in the {owners} linked list.
     *      `SENTINEL_OWNERS` is used to traverse {owners}, such that:
     *      1. `owners[SENTINEL_OWNERS]` contains the first owner
     *      2. `owners[last_owner]` points back to `SENTINEL_OWNERS`
     */
    address internal constant SENTINEL_OWNERS = address(0x1);

    /**
     * @dev The linked list of owners, where `owners[owner]` points to the next in the list.
     *      A mapping is used to allow for `O(1)` inclusion checks.
     */
    mapping(address => address) internal owners;

    /**
     * @dev The number of owners.
     */
    uint256 internal ownerCount;

    /**
     * @dev The threshold of owners required to sign a transaction.
     */
    uint256 internal threshold;

    /**
     * @notice Sets the initial storage of the contract.
     * @param _owners List of Safe owners.
     * @param _threshold Number of required confirmations for a Safe transaction.
     */
    function setupOwners(address[] memory _owners, uint256 _threshold) internal {
        // Threshold can only be 0 at initialization.
        // Check ensures that the setup function can only be called once.
        if (threshold > 0) revertWithError("GS200");
        // Validate that the threshold is smaller than the number of added owners.
        if (_threshold > _owners.length) revertWithError("GS201");
        // There has to be at least one Safe owner.
        if (_threshold == 0) revertWithError("GS202");
        // Initializing Safe owners.
        address currentOwner = SENTINEL_OWNERS;
        uint256 ownersLength = _owners.length;
        for (uint256 i = 0; i < ownersLength; ++i) {
            address owner = _owners[i];
            // We need to check that whether or not the owner can be added before changing state to
            // work with the current ownership formal verification specification. This does mean
            // that we need to additionally check to prevent consecutive owners in `_owners` with
            // the same address to properly prevent duplicates.
            if (owner == currentOwner) revertWithError("GS204");
            requireCanAddOwner(owner);
            owners[currentOwner] = owner;
            currentOwner = owner;
        }
        owners[currentOwner] = SENTINEL_OWNERS;
        ownerCount = ownersLength;
        threshold = _threshold;
    }

    /**
     * @inheritdoc IOwnerManager
     */
    function addOwnerWithThreshold(address owner, uint256 _threshold) public override authorized {
        requireCanAddOwner(owner);
        owners[owner] = owners[SENTINEL_OWNERS];
        owners[SENTINEL_OWNERS] = owner;
        ++ownerCount;
        emit AddedOwner(owner);
        // Change threshold if it was changed.
        if (threshold != _threshold) changeThreshold(_threshold);
    }

    /**
     * @inheritdoc IOwnerManager
     */
    function removeOwner(address prevOwner, address owner, uint256 _threshold) public override authorized {
        // Only allow the removal of an owner if the threshold can still be reached.
        // Here we do pre-decrement as it is cheaper and allows us to check if the threshold is still reachable.
        if (--ownerCount < _threshold) revertWithError("GS201");
        requireCanRemoveOwner(prevOwner, owner);
        owners[prevOwner] = owners[owner];
        owners[owner] = address(0);
        emit RemovedOwner(owner);
        // Change threshold if threshold was changed.
        if (threshold != _threshold) changeThreshold(_threshold);
    }

    /**
     * @inheritdoc IOwnerManager
     */
    function swapOwner(address prevOwner, address oldOwner, address newOwner) public override authorized {
        requireCanAddOwner(newOwner);
        requireCanRemoveOwner(prevOwner, oldOwner);
        owners[newOwner] = owners[oldOwner];
        owners[prevOwner] = newOwner;
        owners[oldOwner] = address(0);
        emit RemovedOwner(oldOwner);
        emit AddedOwner(newOwner);
    }

    /**
     * @notice Checks whether an account is a valid owner address, and reverts if it is not.
     * @param owner The owner address to check.
     */
    function requireIsValidOwner(address owner) internal view {
        // Owner address cannot be null, the sentinel, or the Safe itself (unless it is an EIP-7702 delegated account).
        if (owner == address(0) || owner == SENTINEL_OWNERS || (owner == address(this) && !isThisDelegatedAccount()))
            revertWithError("GS203");
    }

    /**
     * @notice Checks whether an owner address can be added, and reverts if it cannot.
     * @param owner The owner address to check.
     */
    function requireCanAddOwner(address owner) internal view {
        requireIsValidOwner(owner);
        // No duplicate owners allowed.
        if (owners[owner] != address(0)) revertWithError("GS204");
    }

    /**
     * @notice Checks whether an owner address can be removed, and reverts if it cannot.
     * @param prevOwner The owner that points to `owner` in the linked list.
     * @param owner The owner address to check.
     */
    function requireCanRemoveOwner(address prevOwner, address owner) internal view {
        requireIsValidOwner(owner);
        // Check that it corresponds to owner index.
        if (owners[prevOwner] != owner) revertWithError("GS205");
    }

    /**
     * @inheritdoc IOwnerManager
     */
    function changeThreshold(uint256 _threshold) public override authorized {
        // Validate that threshold is smaller than number of owners.
        if (_threshold > ownerCount) revertWithError("GS201");
        // There has to be at least one Safe owner.
        if (_threshold == 0) revertWithError("GS202");
        threshold = _threshold;
        emit ChangedThreshold(_threshold);
    }

    /**
     * @inheritdoc IOwnerManager
     */
    function getThreshold() public view override returns (uint256) {
        return threshold;
    }

    /**
     * @inheritdoc IOwnerManager
     */
    function isOwner(address owner) public view override returns (bool) {
        return !(owner == SENTINEL_OWNERS || owners[owner] == address(0));
    }

    /**
     * @inheritdoc IOwnerManager
     */
    function getOwners() public view override returns (address[] memory) {
        address[] memory array = new address[](ownerCount);

        // Populate return array.
        uint256 index = 0;
        address currentOwner = owners[SENTINEL_OWNERS];
        while (currentOwner != SENTINEL_OWNERS) {
            array[index] = currentOwner;
            currentOwner = owners[currentOwner];
            ++index;
        }
        return array;
    }
}
